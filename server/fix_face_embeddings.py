#!/usr/bin/env python3
"""
Fix Face Embeddings Dimension Issue

This script addresses the dimension mismatch between face embeddings in the database
and those generated by the current InsightFace model. It:

1. Ensures all embeddings in the database have consistent dimensions
2. Updates the database with standardized embeddings
3. Optionally re-enrolls faces from the face_images/temp directory
"""

import os
import sys
import cv2
import numpy as np
import json
import pickle
import mysql.connector
import logging
from typing import Dict, List, Tuple, Any
import glob

# Import face recognition modules
from mediapipe_face import (
    init_face_recognition, 
    extract_faces_from_image,
    recognize_face,
    add_face_to_database,
    load_known_faces_from_db,
    encode_face_for_json,
    face_database,
    get_db_connection,
    FACE_DB_FILE
)

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Standardized embedding size to use
STANDARD_EMBEDDING_SIZE = 512  # InsightFace w600k_r50 model typically outputs 512-dim embeddings

def fix_embedding_dimensions() -> bool:
    """Fix embedding dimensions in the database
    
    Returns:
        True if successful, False otherwise
    """
    # Initialize face recognition
    if not init_face_recognition():
        logger.error("Failed to initialize face recognition")
        return False
    
    logger.info("Loading face database...")
    if not face_database:
        logger.error("Face database is empty")
        return False
    
    logger.info(f"Loaded {len(face_database)} faces from database")
    
    # Check embedding dimensions in database
    dimension_stats = {}
    for name, identity in face_database.items():
        embeddings = identity['embeddings']
        for i, embedding in enumerate(embeddings):
            dim = embedding.shape[0]
            if dim not in dimension_stats:
                dimension_stats[dim] = 0
            dimension_stats[dim] += 1
    
    logger.info(f"Embedding dimension statistics: {dimension_stats}")
    
    # Connect to MySQL database
    conn = get_db_connection()
    if not conn:
        logger.error("Failed to connect to database")
        return False
    
    cursor = conn.cursor(dictionary=True)
    
    # Get all known faces from database
    cursor.execute("SELECT * FROM known_faces")
    known_faces = cursor.fetchall()
    
    logger.info(f"Found {len(known_faces)} faces in MySQL database")
    
    updated_count = 0
    
    # Update embeddings to standard dimension
    for face in known_faces:
        if face and 'face_encoding' in face and face['face_encoding'] and 'name' in face:
            try:
                # Convert to string if it's not already
                face_encoding_str = face['face_encoding']
                if not isinstance(face_encoding_str, str):
                    face_encoding_str = str(face_encoding_str)
                
                # Parse the face encoding
                embedding = np.array(json.loads(face_encoding_str))
                
                # Check if embedding needs standardization
                current_dim = embedding.shape[0]
                if current_dim != STANDARD_EMBEDDING_SIZE:
                    logger.info(f"Updating embedding for {face['name']} from {current_dim} to {STANDARD_EMBEDDING_SIZE} dimensions")
                    
                    # Standardize the embedding
                    if current_dim > STANDARD_EMBEDDING_SIZE:
                        # Truncate to standard size
                        standardized_embedding = embedding[:STANDARD_EMBEDDING_SIZE]
                    else:
                        # Pad with zeros to reach standard size
                        standardized_embedding = np.zeros(STANDARD_EMBEDDING_SIZE)
                        standardized_embedding[:current_dim] = embedding
                    
                    # Normalize the embedding
                    norm = np.linalg.norm(standardized_embedding)
                    if norm > 0:
                        standardized_embedding = standardized_embedding / norm
                    
                    # Encode for storage
                    encoded_embedding = encode_face_for_json(standardized_embedding)
                    
                    # Update in database
                    cursor.execute(
                        "UPDATE known_faces SET face_encoding = %s WHERE known_face_id = %s",
                        (encoded_embedding, face['known_face_id'])
                    )
                    updated_count += 1
            except Exception as e:
                logger.error(f"Error updating embedding for {face.get('name', 'Unknown')}: {e}")
    
    # Commit changes and close connection
    conn.commit()
    cursor.close()
    conn.close()
    
    logger.info(f"Updated {updated_count} face embeddings in database")
    
    # Reload known faces
    load_known_faces_from_db()
    
    return True

def re_enroll_faces_from_temp() -> bool:
    """Re-enroll faces from the temp directory
    
    Returns:
        True if successful, False otherwise
    """
    # Initialize face recognition
    if not init_face_recognition():
        logger.error("Failed to initialize face recognition")
        return False
    
    # Get temp directory path
    temp_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'face_images', 'temp')
    if not os.path.exists(temp_dir):
        logger.error(f"Temp directory not found: {temp_dir}")
        return False
    
    # Get all person directories
    person_dirs = [d for d in os.listdir(temp_dir) if os.path.isdir(os.path.join(temp_dir, d))]
    
    if not person_dirs:
        logger.error(f"No person directories found in {temp_dir}")
        return False
    
    logger.info(f"Found {len(person_dirs)} person directories: {', '.join(person_dirs)}")
    
    # Connect to MySQL database
    conn = get_db_connection()
    if not conn:
        logger.error("Failed to connect to database")
        return False
    
    cursor = conn.cursor(dictionary=True)
    
    # Process each person directory
    for person_dir in person_dirs:
        person_name = person_dir  # Directory name is the person name
        person_path = os.path.join(temp_dir, person_dir)
        
        # Get all jpg files in the directory
        image_files = glob.glob(os.path.join(person_path, "*.jpg"))
        
        if not image_files:
            logger.info(f"No jpg images found for {person_name}")
            continue
        
        logger.info(f"Found {len(image_files)} images for {person_name}")
        
        # Detect and enroll faces for each image
        face_count = 0
        for image_path in image_files[:5]:  # Limit to first 5 images
            if os.path.basename(image_path).startswith(("debug_", "detected_", "recognized_")):
                continue  # Skip debug/result images
                
            logger.info(f"Processing {os.path.basename(image_path)} for {person_name}")
            
            # Extract faces
            faces = extract_faces_from_image(image_path)
            
            if not faces:
                logger.info(f"No faces detected in {os.path.basename(image_path)}")
                continue
            
            # Use the face with the largest bounding box (usually the main subject)
            best_face = max(faces, key=lambda f: 
                (f['bbox'][2] - f['bbox'][0]) * (f['bbox'][3] - f['bbox'][1]))
            
            # Check for existing person in database
            cursor.execute("SELECT * FROM known_faces WHERE name = %s", (person_name,))
            existing_person = cursor.fetchone()
            
            if existing_person:
                # Update existing person
                # First check embedding dimension
                embedding = best_face['embedding']
                current_dim = embedding.shape[0]
                
                if current_dim != STANDARD_EMBEDDING_SIZE:
                    logger.info(f"Standardizing embedding from {current_dim} to {STANDARD_EMBEDDING_SIZE} dimensions")
                    
                    # Standardize the embedding
                    if current_dim > STANDARD_EMBEDDING_SIZE:
                        embedding = embedding[:STANDARD_EMBEDDING_SIZE]
                    else:
                        std_embedding = np.zeros(STANDARD_EMBEDDING_SIZE)
                        std_embedding[:current_dim] = embedding
                        embedding = std_embedding
                    
                    # Normalize the embedding
                    norm = np.linalg.norm(embedding)
                    if norm > 0:
                        embedding = embedding / norm
                    
                    # Update the face data
                    best_face['embedding'] = embedding
                
                # Update in database
                encoded_embedding = encode_face_for_json(embedding)
                cursor.execute(
                    "UPDATE known_faces SET face_encoding = %s WHERE known_face_id = %s",
                    (encoded_embedding, existing_person['known_face_id'])
                )
                logger.info(f"Updated face encoding for {person_name}")
            else:
                # Add new person
                # Check embedding dimension
                embedding = best_face['embedding']
                current_dim = embedding.shape[0]
                
                if current_dim != STANDARD_EMBEDDING_SIZE:
                    logger.info(f"Standardizing embedding from {current_dim} to {STANDARD_EMBEDDING_SIZE} dimensions")
                    
                    # Standardize the embedding
                    if current_dim > STANDARD_EMBEDDING_SIZE:
                        embedding = embedding[:STANDARD_EMBEDDING_SIZE]
                    else:
                        std_embedding = np.zeros(STANDARD_EMBEDDING_SIZE)
                        std_embedding[:current_dim] = embedding
                        embedding = std_embedding
                    
                    # Normalize the embedding
                    norm = np.linalg.norm(embedding)
                    if norm > 0:
                        embedding = embedding / norm
                    
                    # Update the face data
                    best_face['embedding'] = embedding
                
                # Insert into database
                encoded_embedding = encode_face_for_json(embedding)
                cursor.execute(
                    """INSERT INTO known_faces 
                       (name, role, face_encoding, access_bedroom, access_living_room, access_kitchen, access_front_door) 
                       VALUES (%s, %s, %s, %s, %s, %s, %s)""",
                    (person_name, "Person", encoded_embedding, True, True, True, True)
                )
                logger.info(f"Added new person: {person_name}")
            
            face_count += 1
            
            # Limit to one face per person for simplicity
            break
        
        logger.info(f"Processed {face_count} faces for {person_name}")
    
    # Commit changes and close connection
    conn.commit()
    cursor.close()
    conn.close()
    
    # Reload known faces
    load_known_faces_from_db()
    
    return True

def main():
    # Fix embedding dimensions in database
    logger.info("Starting to fix embedding dimensions...")
    if fix_embedding_dimensions():
        logger.info("Successfully fixed embedding dimensions")
    else:
        logger.error("Failed to fix embedding dimensions")
    
    # Re-enroll faces from temp directory
    logger.info("\nStarting to re-enroll faces from temp directory...")
    if re_enroll_faces_from_temp():
        logger.info("Successfully re-enrolled faces")
    else:
        logger.error("Failed to re-enroll faces")
    
    # Test recognition after fixes
    logger.info("\nTesting face recognition after fixes...")
    try:
        # Run the mediapipe_face_temp.py script to test recognition
        test_script_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'test_mediapipe_face_temp.py')
        if os.path.exists(test_script_path):
            logger.info(f"Running test script: {test_script_path}")
            logger.info("Please check the output to verify recognition is working correctly")
            logger.info("To run the test script, use: python test_mediapipe_face_temp.py")
    except Exception as e:
        logger.error(f"Error testing recognition: {e}")
    
    logger.info("Finished all operations")

if __name__ == "__main__":
    main() 